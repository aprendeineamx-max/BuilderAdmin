-- Phase 13: Learning Path Certificates (CORRECTED)
-- Certificados al completar rutas completas de aprendizaje

-- 1. Table: Path Certificates
CREATE TABLE IF NOT EXISTS public.path_certificates (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    student_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    ruta_id BIGINT REFERENCES public.rutas(id) ON DELETE CASCADE NOT NULL,
    ruta_name TEXT NOT NULL,
    issued_at TIMESTAMPTZ DEFAULT NOW(),
    validation_code TEXT UNIQUE NOT NULL,
    blockchain_tx_hash TEXT,
    chain_id INTEGER,
    minted_at TIMESTAMPTZ,
    UNIQUE(student_id, ruta_id) -- Solo un certificado por ruta por estudiante
);

-- 2. Table: Path Progress (Track user completion)
CREATE TABLE IF NOT EXISTS public.path_progress (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    ruta_id BIGINT REFERENCES public.rutas(id) ON DELETE CASCADE NOT NULL,
    completed_courses JSONB DEFAULT '[]'::jsonb, -- Array of course IDs completed
    total_courses INTEGER DEFAULT 0, -- Total courses in the path
    completion_percentage INTEGER DEFAULT 0,
    completed_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, ruta_id)
);

-- 3. Function: Generate unique validation code
CREATE OR REPLACE FUNCTION generate_path_cert_code()
RETURNS TEXT AS $$
DECLARE
    code TEXT;
BEGIN
    code := 'RUTA-' || UPPER(SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8));
    RETURN code;
END;
$$ LANGUAGE plpgsql;

-- 4. Function: Auto-generate validation code on insert
CREATE OR REPLACE FUNCTION set_path_cert_validation_code()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.validation_code IS NULL OR NEW.validation_code = '' THEN
        NEW.validation_code := generate_path_cert_code();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5. Trigger for validation code
DROP TRIGGER IF EXISTS path_cert_validation_code_trigger ON public.path_certificates;
CREATE TRIGGER path_cert_validation_code_trigger
    BEFORE INSERT ON public.path_certificates
    FOR EACH ROW
    EXECUTE FUNCTION set_path_cert_validation_code();

-- 6. Function: Update path progress timestamp
CREATE OR REPLACE FUNCTION update_path_progress_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    
    -- Auto-calculate completion percentage
    IF NEW.total_courses > 0 THEN
        NEW.completion_percentage = (jsonb_array_length(NEW.completed_courses) * 100) / NEW.total_courses;
    END IF;
    
    -- Mark as completed if 100%
    IF NEW.completion_percentage >= 100 AND NEW.completed_at IS NULL THEN
        NEW.completed_at = NOW();
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 7. Trigger for progress updates
DROP TRIGGER IF EXISTS path_progress_update_trigger ON public.path_progress;
CREATE TRIGGER path_progress_update_trigger
    BEFORE UPDATE ON public.path_progress
    FOR EACH ROW
    EXECUTE FUNCTION update_path_progress_timestamp();

-- 8. Enable RLS
ALTER TABLE public.path_certificates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.path_progress ENABLE ROW LEVEL SECURITY;

-- 9. RLS Policies: Path Certificates
-- Public can verify (read)
CREATE POLICY "Path Certificates Public Read" 
    ON public.path_certificates FOR SELECT 
    USING (true);

-- Only system can insert (via API with service role)
CREATE POLICY "Path Certificates System Insert" 
    ON public.path_certificates FOR INSERT 
    WITH CHECK (auth.role() = 'authenticated');

-- 10. RLS Policies: Path Progress
-- Users can read their own progress
CREATE POLICY "Path Progress Own Read" 
    ON public.path_progress FOR SELECT 
    USING (auth.uid() = user_id);

-- Users can insert their own progress
CREATE POLICY "Path Progress Own Insert" 
    ON public.path_progress FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Users can update their own progress
CREATE POLICY "Path Progress Own Update" 
    ON public.path_progress FOR UPDATE 
    USING (auth.uid() = user_id);

-- 11. Indexes for performance
CREATE INDEX IF NOT EXISTS idx_path_certs_student ON public.path_certificates(student_id);
CREATE INDEX IF NOT EXISTS idx_path_certs_ruta ON public.path_certificates(ruta_id);
CREATE INDEX IF NOT EXISTS idx_path_certs_validation ON public.path_certificates(validation_code);
CREATE INDEX IF NOT EXISTS idx_path_progress_user ON public.path_progress(user_id);
CREATE INDEX IF NOT EXISTS idx_path_progress_ruta ON public.path_progress(ruta_id);

-- 12. Seed Data (Demo certificate for testing)
DO $$
DECLARE
    demo_user_id UUID;
    demo_ruta_id BIGINT;
    demo_ruta_name TEXT;
BEGIN
    -- Try to get first user
    SELECT id INTO demo_user_id FROM auth.users LIMIT 1;
    
    -- Try to get first ruta
    SELECT id, name INTO demo_ruta_id, demo_ruta_name FROM public.rutas LIMIT 1;
    
    -- Only seed if both exist
    IF demo_user_id IS NOT NULL AND demo_ruta_id IS NOT NULL THEN
        -- Insert progress (100% complete)
        INSERT INTO public.path_progress (user_id, ruta_id, completed_courses, total_courses, completion_percentage, completed_at)
        VALUES (
            demo_user_id,
            demo_ruta_id,
            '[1, 2, 3]'::jsonb, -- Mock course IDs
            3,
            100,
            NOW()
        )
        ON CONFLICT (user_id, ruta_id) DO NOTHING;
        
        -- Insert certificate
        INSERT INTO public.path_certificates (student_id, ruta_id, ruta_name, validation_code)
        VALUES (
            demo_user_id,
            demo_ruta_id,
            COALESCE(demo_ruta_name, 'Ruta Demo'),
            'RUTA-DEMO001'
        )
        ON CONFLICT (student_id,ruta_id) DO NOTHING;
    END IF;
END $$;
